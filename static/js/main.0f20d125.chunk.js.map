{"version":3,"sources":["store/Grid.module.css","components/header.module.css","store/store.js","components/BFS.js","components/Grid.js","components/Header.js","components/App.js","serviceWorker.js","index.js"],"names":["module","exports","gird","Array","fill","i","length","state","color","girdStyle","red","initialState","grid","start","end","store","createStore","action","type","newGrid","row","column","element","pathGrid","sleep","milliseconds","Promise","resolve","reject","setTimeout","bfs","startCoordinates","callback","a","distanceFromTop","distanceFromLeft","queue","path","status","visited","Set","currentLocation","shift","exploreInDirection","newLocationNorth","push","newLocationEast","newLocationSouth","newLocationWest","locationStatus","location","set","maxRowSize","maxColSize","dft","dfl","has","direction","newPath","slice","newLocation","add","Grid","search","props","paint","ans","North","South","West","East","startrow","startcol","dr","paintPath","handleMousrover","bind","col","this","id","style","width","height","onClick","onMouseDown","setState","onMouseUp","map","rowIndex","key","cellIndex","onMouseOver","className","Component","connect","dispatch","colorize","Header","headerStyle","header","clear","React","App","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0f20d125.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"element\":\"Grid_element__1gWPd\",\"stretch\":\"Grid_stretch__2x8gV\",\"red\":\"Grid_red__3mEZA\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"header_header__2eggW\"};","import { createStore, applyMiddleware } from 'redux';\nimport loggerMiddleware from 'redux-logger';\nimport girdStyle from './Grid.module.css';\nimport Grid from '../components/Grid';\nimport { act } from 'react-dom/test-utils';\n\nlet gird = new Array(20).fill([]);\nfor (let i = 0; i < gird.length; ++i) {\n  gird[i] = new Array(40).fill({ state: 'Empty', color: '' });\n}\ngird[10][10] = { state: 'start', color: girdStyle.red };\ngird[10][39] = { state: 'Goal', color: girdStyle.red };\n// gird[10][10] = { state: 1, color: girdStyle.red };\nconst initialState = {\n  grid: gird,\n  start: [10, 10],\n  end: [gird.length - 1, gird[0].length - 1],\n};\n// const initialState = { grid: Array(20).fill(Array(80).fill('')) };\n\n//action type\nconst COLORIZE = 'COLORIZE';\nconst CLEAR = 'CLEAR';\nconst SET_START = 'SET_START';\nconst PAINT_PATH = 'PAINT_PATH';\n//action creator\nexport const colorize = (row, column) => ({ type: COLORIZE, row, column });\nexport const clear = () => ({ type: CLEAR });\nexport const setStart = (start) => ({ type: SET_START, start });\nexport const paintPath = (row, column) => ({ type: PAINT_PATH, row, column });\n//reducer\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    case COLORIZE:\n      const newGrid = [...state.grid];\n\n      newGrid[action.row] = [...newGrid[action.row]];\n\n      newGrid[action.row][action.column] = {\n        ...newGrid[action.row][action.column],\n      };\n      if (newGrid[action.row][action.column].color === '') {\n        newGrid[action.row][action.column].state = 'Visited';\n        newGrid[action.row][action.column].color = girdStyle.element;\n      }\n      return { ...state, grid: newGrid };\n    case CLEAR:\n      return initialState;\n    case SET_START:\n      return { ...state, start: action.start };\n    case PAINT_PATH:\n      //[east,north,south,west]\n      const pathGrid = [...state.grid];\n      pathGrid[action.row][action.column] = {\n        ...pathGrid[action.row][action.column],\n      };\n      pathGrid[action.row][action.column].color = 'red';\n      return { ...state, grid: pathGrid };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(reducer);\n\nexport default store;\n","const sleep = (milliseconds) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\n// export const bfs = async (grid, start, destination, callback) => {\n//   let disMin = Number.MAX_SAFE_INTEGER;\n//   const visited = new Map();\n//   const dirs = [\n//     [-1, 0],\n//     [1, 0],\n//     [0, -1],\n//     [0, 1],\n//   ];\n//   const isOutside = (i, j) => {\n//     return i < 0 || j < 0 || i >= grid.length || j >= grid[0].length;\n//   };\n\n//   const roll = (i, j, dir) => {\n//     while (\n//       !isOutside(i + dir[0], j + dir[1]) &&\n//       grid[i + dir[0]][j + dir[1]].state !== 1\n//     ) {\n//       console.log(i + dir[0], j + dir[1]);\n//       i += dir[0];\n//       j += dir[1];\n//     }\n//     console.log(i + dir[0], j + dir[1]);\n//     return [i, j];\n//   };\n\n//   //bfs\n//   const helper = (i, j) => {\n//     const queue = [[i, j, 0]];\n//     while (queue.length) {\n//       const { length } = queue;\n\n//       for (let i = 0; i < length; i++) {\n//         const [x, y, dis] = queue.pop();\n//         const key = `${x}|${y}`;\n\n//         if (x === destination[0] && y === destination[1])\n//           disMin = Math.min(disMin, dis);\n//         console.log(dis);\n//         if (visited.has(key) && dis >= visited.get(key)) continue; // key condition\n\n//         visited.set(key, dis);\n\n//         // break into four directions\n//         const up = roll(x, y, [-1, 0]);\n//         const down = roll(x, y, [1, 0]);\n//         const left = roll(x, y, [0, -1]);\n//         const right = roll(x, y, [0, 1]);\n//         // console.log(up, down, left, right);\n//         if (up) queue.unshift([up, dis + Math.abs(up[0] - x)]);\n//         if (down) queue.unshift([...down, dis + Math.abs(down[0] - x)]);\n//         if (left) queue.unshift([...left, dis + Math.abs(left[1] - y)]);\n//         if (right) queue.unshift([...right, dis + Math.abs(right[1] - y)]);\n\n//         // or one-liner\n//         // dirs\n//         //   .map((dir) => roll(x, y, dir))\n//         //   .forEach(([a, b]) =>\n//         //     queue.unshift([a, b, dis + Math.abs(x - a) + Math.abs(y - b)])\n//         //   );\n//       }\n//     }\n//     return disMin !== Number.MAX_VALUE ? disMin : -1;\n//   };\n//   let result = helper(start[0], start[1]);\n//   console.log(result);\n//   return helper(start[0], start[1]);\n//   //   const [row, col] = start;\n//   //   const [endRow, endCol] = end;\n//   //   let queue = [[row, col]];\n\n//   //   let set = new Set();\n//   //   while (queue.length > 0) {\n//   //     const [row, col] = queue.shift();\n\n//   //     if (\n//   //       row < 0 ||\n//   //       col < 0 ||\n//   //       row >= grid.length ||\n//   //       col >= grid[0].length ||\n//   //       grid[row][col].state !== 0 ||\n//   //       set.has(`${row}+#${col}`)\n//   //     ) {\n//   //       continue;\n//   //     }\n\n//   //     callback(row, col);\n//   //     set.add(`${row}+#${col}`);\n//   //     await sleep(0);\n//   //     if (row === endRow && col === endCol) {\n//   //       break;\n//   //     }\n\n//   //     queue.push([row, col - 1]);\n//   //     queue.push([row, col + 1]);\n//   //     queue.push([row + 1, col]);\n//   //     queue.push([row - 1, col]);\n//   //   }\n// };\n// Start location will be in the following format:\n// [distanceFromTop, distanceFromLeft]\nexport const bfs = async function (grid, startCoordinates, callback) {\n  var distanceFromTop = startCoordinates[0];\n  var distanceFromLeft = startCoordinates[1];\n\n  // Each \"location\" will store its coordinates\n  // and the shortest path required to arrive there\n  var location = {\n    distanceFromTop: distanceFromTop,\n    distanceFromLeft: distanceFromLeft,\n    path: [],\n    status: 'Start',\n  };\n\n  // Initialize the queue with the start location already inside\n  var queue = [location];\n  const visited = new Set();\n  // Loop through the grid searching for the goal\n  while (queue.length > 0) {\n    // Take the first location off the queue\n    var currentLocation = queue.shift();\n    // callback(currentLocation.distanceFromTop, currentLocation.distanceFromLeft);\n    // await sleep(0);\n    // Explore North\n    var newLocationNorth = await exploreInDirection(\n      currentLocation,\n      'North',\n      grid,\n      callback,\n      visited\n    );\n\n    if (newLocationNorth.status === 'Goal') {\n      return newLocationNorth.path;\n    } else if (newLocationNorth.status === 'Valid') {\n      queue.push(newLocationNorth);\n    }\n\n    // Explore East\n    var newLocationEast = await exploreInDirection(\n      currentLocation,\n      'East',\n      grid,\n      callback,\n      visited\n    );\n    if (newLocationEast.status === 'Goal') {\n      return newLocationEast.path;\n    } else if (newLocationEast.status === 'Valid') {\n      queue.push(newLocationEast);\n    }\n\n    // Explore South\n    var newLocationSouth = await exploreInDirection(\n      currentLocation,\n      'South',\n      grid,\n      callback,\n      visited\n    );\n    if (newLocationSouth.status === 'Goal') {\n      return newLocationSouth.path;\n    } else if (newLocationSouth.status === 'Valid') {\n      queue.push(newLocationSouth);\n    }\n\n    // Explore West\n    var newLocationWest = await exploreInDirection(\n      currentLocation,\n      'West',\n      grid,\n      callback,\n      visited\n    );\n    if (newLocationWest.status === 'Goal') {\n      return newLocationWest.path;\n    } else if (newLocationWest.status === 'Valid') {\n      queue.push(newLocationWest);\n    }\n  }\n\n  // No valid path found\n  return false;\n};\n\n// This function will check a location's status\n// (a location is \"valid\" if it is on the grid, is not an \"obstacle\",\n// and has not yet been visited by our algorithm)\n// Returns \"Valid\", \"Invalid\", \"Blocked\", or \"Goal\"\nvar locationStatus = function (location, grid, set) {\n  var maxRowSize = grid.length;\n  var maxColSize = grid[0].length;\n  var dft = location.distanceFromTop;\n  var dfl = location.distanceFromLeft;\n\n  if (\n    location.distanceFromLeft < 0 ||\n    location.distanceFromLeft >= maxColSize ||\n    location.distanceFromTop < 0 ||\n    location.distanceFromTop >= maxRowSize ||\n    set.has(`${location.distanceFromTop}|${location.distanceFromLeft}`)\n  ) {\n    // location is not on the grid--return false\n    return 'Invalid';\n  } else if (grid[dft][dfl].state === 'Goal') {\n    return 'Goal';\n  } else if (grid[dft][dfl].state !== 'Empty') {\n    // location is either an obstacle or has been visited\n    return 'Blocked';\n  } else {\n    return 'Valid';\n  }\n};\n\n// Explores the grid from the given location in the given\n// direction\nvar exploreInDirection = async function (\n  currentLocation,\n  direction,\n  grid,\n  callback,\n  set\n) {\n  var newPath = currentLocation.path.slice();\n  newPath.push(direction);\n\n  var dft = currentLocation.distanceFromTop;\n  var dfl = currentLocation.distanceFromLeft;\n\n  if (direction === 'North') {\n    dft -= 1;\n  } else if (direction === 'East') {\n    dfl += 1;\n  } else if (direction === 'South') {\n    dft += 1;\n  } else if (direction === 'West') {\n    dfl -= 1;\n  }\n\n  var newLocation = {\n    distanceFromTop: dft,\n    distanceFromLeft: dfl,\n    path: newPath,\n    status: 'Unknown',\n  };\n  newLocation.status = locationStatus(newLocation, grid, set);\n  // callback(newLocation.distanceFromTop, newLocation.distanceFromLeft);\n  // await sleep(0);\n  // If this new location is valid, mark it as 'Visited'\n  if (newLocation.status === 'Valid') {\n    // grid[newLocation.distanceFromTop][newLocation.distanceFromLeft] = 'Visited';\n    set.add(`${newLocation.distanceFromTop}|${newLocation.distanceFromLeft}`);\n    callback(newLocation.distanceFromTop, newLocation.distanceFromLeft);\n    await sleep(0);\n  }\n\n  return newLocation;\n};\n","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { colorize, paintPath } from '../store/store';\nimport { bfs } from './BFS';\n\nconst sleep = (milliseconds) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\nclass Grid extends Component {\n  constructor() {\n    super();\n    this.state = {\n      paint: false,\n    };\n\n    this.handleMousrover = this.handleMousrover.bind(this);\n  }\n\n  handleMousrover(row, col) {\n    if (this.state.paint) {\n      this.props.paint(row, col);\n    }\n  }\n  search = async (grid, start) => {\n    let ans = await bfs(grid, start, this.props.paint);\n    //north,south west    east\n    let direction = {\n      North: [-1, 0],\n      South: [1, 0],\n      West: [0, -1],\n      East: [0, 1],\n    };\n\n    let startrow = start[0];\n    let startcol = start[1];\n    for (let i = 0; i < ans.length; ++i) {\n      let dr = direction[ans[i]];\n      startrow += dr[0];\n      startcol += dr[1];\n      this.props.paintPath(startrow, startcol);\n      await sleep(100);\n    }\n    // console.log(this.props.grid);\n  };\n  render() {\n    const { grid, start, end } = this.props;\n\n    return (\n      <div id='pixelate'>\n        {/* truncated for brevity... */}\n        {/* bfs(grid, start, end, this.props.paint) */}\n        <button\n          style={{ width: 50, height: 50 }}\n          onClick={() => this.search(grid, start)}\n        >\n          Start\n        </button>\n        <table\n          onMouseDown={() => this.setState({ paint: true })}\n          onMouseUp={() => this.setState({ paint: false })}\n        >\n          <tbody>\n            {grid.map((row, rowIndex) => (\n              <tr key={rowIndex}>\n                {row.map((color, cellIndex) => (\n                  <td\n                    key={cellIndex}\n                    onMouseOver={() =>\n                      this.handleMousrover(rowIndex, cellIndex)\n                    }\n                    onClick={() => {\n                      this.props.paint(rowIndex, cellIndex);\n                    }}\n                    className={grid[rowIndex][cellIndex].color}\n                  ></td>\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\nconst mapState = (state) => {\n  return {\n    grid: state.grid,\n    start: state.start,\n    end: state.end,\n  };\n};\nconst mapDispatch = (dispatch) => {\n  return {\n    paint: (row, col) => dispatch(colorize(row, col)),\n    paintPath: (row, col) => dispatch(paintPath(row, col)),\n  };\n};\nexport default connect(mapState, mapDispatch)(Grid);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { clear } from '../store/store';\nimport headerStyle from './header.module.css';\nclass Header extends React.Component {\n  constructor() {\n    super();\n  }\n  render() {\n    return (\n      <div className={headerStyle.header}>\n        <h3>PathFinding Visualizer</h3>\n        <button onClick={this.props.clear}>Clear</button>\n      </div>\n    );\n  }\n}\n\nconst mapDispatch = (dispatch) => {\n  return {\n    clear: () => dispatch(clear()),\n  };\n};\n\nexport default connect(null, mapDispatch)(Header);\n","import React from 'react';\n\nimport './App.css';\nimport Grid from './Grid';\nimport Header from './Header';\nfunction App() {\n  return (\n    <div className='App'>\n      <Header />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\nimport store from './store/store';\nReactDOM.render(\n  <Provider store={store}>\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  </Provider>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}